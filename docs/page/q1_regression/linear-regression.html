<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>重回帰分析 – 研究室の机</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-e6075c022d5696f18ab0a54e110e299c.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "一致なし",
    "search-matching-documents-text": "一致した文書",
    "search-copy-link-title": "検索へのリンクをコピー",
    "search-hide-matches-text": "追加の検索結果を非表示",
    "search-more-match-text": "追加の検索結果",
    "search-more-matches-text": "追加の検索結果",
    "search-clear-button-title": "消去",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "検索",
    "search-label": "サーチ"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">研究室の机</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="サーチ"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="ナビゲーションを切り替える" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../page/blog.html"> 
<span class="menu-text">メモあつめ</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">目次</h2>
   
  <ul>
  <li><a href="#重要な用語と少しだけ数学" id="toc-重要な用語と少しだけ数学" class="nav-link active" data-scroll-target="#重要な用語と少しだけ数学">重要な用語と、少しだけ数学</a>
  <ul class="collapse">
  <li><a href="#独立変数従属変数" id="toc-独立変数従属変数" class="nav-link" data-scroll-target="#独立変数従属変数">独立変数、従属変数</a></li>
  <li><a href="#確率変数" id="toc-確率変数" class="nav-link" data-scroll-target="#確率変数">確率変数</a></li>
  <li><a href="#期待値条件付き期待値" id="toc-期待値条件付き期待値" class="nav-link" data-scroll-target="#期待値条件付き期待値">期待値、条件付き期待値</a></li>
  </ul></li>
  <li><a href="#回帰モデルの基礎" id="toc-回帰モデルの基礎" class="nav-link" data-scroll-target="#回帰モデルの基礎">回帰モデルの基礎</a>
  <ul class="collapse">
  <li><a href="#boldsymbolbeta-の推定" id="toc-boldsymbolbeta-の推定" class="nav-link" data-scroll-target="#boldsymbolbeta-の推定"><span class="math inline">\(\boldsymbol{\beta}\)</span> の推定</a></li>
  </ul></li>
  <li><a href="#回帰表の解釈" id="toc-回帰表の解釈" class="nav-link" data-scroll-target="#回帰表の解釈">回帰表の解釈</a>
  <ul class="collapse">
  <li><a href="#回帰表と回帰係数" id="toc-回帰表と回帰係数" class="nav-link" data-scroll-target="#回帰表と回帰係数">回帰表と回帰係数</a></li>
  <li><a href="#推定の不確実性と信頼区間統計的仮説検定" id="toc-推定の不確実性と信頼区間統計的仮説検定" class="nav-link" data-scroll-target="#推定の不確実性と信頼区間統計的仮説検定">推定の不確実性と信頼区間、統計的仮説検定</a></li>
  <li><a href="#回帰分析の指標決定係数" id="toc-回帰分析の指標決定係数" class="nav-link" data-scroll-target="#回帰分析の指標決定係数">回帰分析の指標、決定係数</a></li>
  </ul></li>
  <li><a href="#回帰係数が正しく推定されるための仮定" id="toc-回帰係数が正しく推定されるための仮定" class="nav-link" data-scroll-target="#回帰係数が正しく推定されるための仮定">回帰係数が正しく推定されるための仮定</a>
  <ul class="collapse">
  <li><a href="#i.i.d.-の仮定" id="toc-i.i.d.-の仮定" class="nav-link" data-scroll-target="#i.i.d.-の仮定">1. i.i.d. の仮定</a></li>
  <li><a href="#外生性の仮定" id="toc-外生性の仮定" class="nav-link" data-scroll-target="#外生性の仮定">2. 外生性の仮定</a></li>
  <li><a href="#多重共線性がない" id="toc-多重共線性がない" class="nav-link" data-scroll-target="#多重共線性がない">3. 多重共線性がない</a></li>
  <li><a href="#異常値がない" id="toc-異常値がない" class="nav-link" data-scroll-target="#異常値がない">4. 異常値がない</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">重回帰分析</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>この記事では、定量的な分析の基本的な手法である回帰分析のうち、もっとも基本的な線形重回帰分析について扱います。なお、他の回帰分析にも通じる根本的な概念を説明しているため、かなり長くなっています。他の手法でわからない説明も、ここに戻ってくれば見つかるかもしれません。</p>
<section id="重要な用語と少しだけ数学" class="level2">
<h2 class="anchored" data-anchor-id="重要な用語と少しだけ数学">重要な用語と、少しだけ数学</h2>
<section id="独立変数従属変数" class="level3">
<h3 class="anchored" data-anchor-id="独立変数従属変数">独立変数、従属変数</h3>
<p>多くの実証的な研究の仮説は、原因と結果の間に存在する因果メカニズムまたはその効果に関する記述です。この枠組みにおいて、原因の部分を独立変数といい、結果の部分を従属変数といいます。統計学または計量経済学での数式の慣習から、一般的に独立変数は <span class="math inline">\(X\)</span> で、従属変数は <span class="math inline">\(Y\)</span> で表されます。また、独立変数が複数ある場合は <span class="math inline">\(X_1, X_2, \cdots\)</span> というふうに、右下に数字をつけることにします。</p>
<p>独立変数はほかにも、説明変数、原因変数、処置変数などと呼ぶことがあります。従属変数は、非説明変数、結果変数などと呼ぶことがあります。これらは主に分野による慣習の違いですが、どれを聞いてもどちらかわかるようにしておいてください。なお英語では、それぞれ Independent Variable と Dependent Variable です。</p>
</section>
<section id="確率変数" class="level3">
<h3 class="anchored" data-anchor-id="確率変数">確率変数</h3>
<p>確率変数とは、その値が確率的に決まる変数のことをいいます。サイコロの出目などがわかり易い例です。計量政治学では、多くの変数は確率的に決まるものとみなされます。例えばある国の民主主義指数とか、戦争を起こしたかどうかとか、選挙の結果とか。テストの得点も確率変数です。これは、「あなたが95点を確率的に（たまたま）取った」という意味ではなく、「95点を含むあらゆる得点は事前に決まっている確率的な分布に従って現れた 」という意味です。ちなみにテストの得点はたいてい、正規分布に従うような分布をしています。不思議ですね。</p>
</section>
<section id="期待値条件付き期待値" class="level3">
<h3 class="anchored" data-anchor-id="期待値条件付き期待値">期待値、条件付き期待値</h3>
<p>期待値とは、ある確率変数が確率的にとる値の平均のことをいいます。確率変数 <span class="math inline">\(X\)</span> の期待値は <span class="math inline">\(E[X]\)</span> で表されます。例えば、 <span class="math inline">\(X\)</span> をサイコロの出目とすれば、 <span class="math inline">\(E[X] = 3.5\)</span> となります (定義や計算は省略)。もちろん、サイコロを振っても3.5という出目はでませんし、3.5 に近い値が出やすいというわけでもありません。あくまで、平均をとると3.5になるという意味です。</p>
<p>条件付き期待値とは、ある事象が与えられたという条件のもとでの、ある確率変数が確率的に取る値の平均をいいます。別の確率変数 <span class="math inline">\(Z\)</span> が与えられたときの変数 <span class="math inline">\(X\)</span> の条件付き期待値は、 <span class="math inline">\(E[X \| Z]\)</span> と表し、これは変数 <span class="math inline">\(Z\)</span> の値によって変わるので、 <span class="math inline">\(Z\)</span> の関数です。とくに、 <span class="math inline">\(Z = z\)</span> のときの変数 <span class="math inline">\(X\)</span> の条件付き期待値を <span class="math inline">\(E[X \| Z = z]\)</span> と表します。例えば、全校生徒のテストの点数を <span class="math inline">\(X\)</span> とすれば、 <span class="math inline">\(E[X \| grade = 3]\)</span> は3年生の得点の期待値となります。</p>
<p>このシリーズを読むのに必要な数学の知識はこれくらいです。ここまでの数学知識をきちんと学びたい方は、統計学 (確率論ではない) のテキストを読んでください。</p>
</section>
</section>
<section id="回帰モデルの基礎" class="level2">
<h2 class="anchored" data-anchor-id="回帰モデルの基礎">回帰モデルの基礎</h2>
<p>いま、 <span class="math inline">\(Y\)</span> に与える影響を知りたい変数が <span class="math inline">\(M\)</span> 個あるとし、それらを <span class="math inline">\(X_1, \cdots, X_M\)</span> とします。ただし、いちいち書き並べるのは面倒なので、太字で <span class="math inline">\(\boldsymbol{X} = (X_1, \cdots, X_M)\)</span> と書くことにしましょう。そして、独立変数と従属変数の間に次の一次関数の関係があると仮定します<a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>。</p>
<p><a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>: この「仮定」という考えが、実はとても重要だと考えています。すなわち、実際にそうであるかは未知 (神のみぞ知る) なのだが、一旦そのような関係性を仮定し、そこから政治学的に重要な示唆を数学的に導き出すという手順が、「モデル」に基づく推測の本質です。</p>
<p><span class="math display">\[
Y = \beta_0 + \beta_1X_1 + \cdots + \beta_M X_M + \varepsilon
\]</span></p>
<p>この式を回帰式とか回帰モデルといいます。この式は、中学生のときに学んだ一次関数の式を拡張したものです。右辺の <span class="math inline">\(\beta_0\)</span> は切片を表し、 <span class="math inline">\(\beta_1\)</span> は変数 <span class="math inline">\(X_1\)</span> の係数、つまり傾きを表しています。中学校の教科書によれば、一次関数の傾きは（ <span class="math inline">\(y\)</span> の増加量）÷ ( <span class="math inline">\(x\)</span> の増加量）で求められるのでした。つまり係数とは、 <span class="math inline">\(x\)</span> が「1単位」増加したときに <span class="math inline">\(y\)</span> がどの程度増加するかを表しています。</p>
<p>このことを今紹介したモデルに当てはめれば、ある変数 <span class="math inline">\(X_k\)</span> が1増加したとき、 <span class="math inline">\(Y\)</span> の期待値は <span class="math inline">\(\beta_k\)</span> だけ増加することになります。</p>
<p>この式から、ある示唆が得られます。すなわち、 <span class="math inline">\(\beta_0, \beta_1, \cdots, \beta_M\)</span> の値がわかれば、各独立変数 <span class="math inline">\(X\)</span> が従属変数 <span class="math inline">\(Y\)</span> に与える影響の大きさがわかるということです<a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>。したがって、 <span class="math inline">\(\beta_0, \beta_1, \cdots, \beta_M\)</span> の値を知ること (推定すること) が、回帰分析の次なる目標になります。なおこれ以降、やはり書き並べるのが面倒なので、太字で <span class="math inline">\(\boldsymbol{\beta} = (\beta_1, \cdots, \beta_M)\)</span> と書くことにします。</p>
<p>M個の独立変数 <span class="math inline">\(\boldsymbol{X}\)</span> によってでも、<span class="math inline">\(Y\)</span> の値は完全に説明されるとは限りません。他にさらなる変数が存在したり、測定による誤差が生じたりするかもしれないためです。このような、独立変数 <span class="math inline">\(\boldsymbol{X}\)</span> で予測される <span class="math inline">\(Y\)</span> の値と観測された真の値との差を表す部分を誤差項といい、式の中の <span class="math inline">\(\varepsilon\)</span> がこれに当たります。ここではひとまず、独立変数 <span class="math inline">\(\boldsymbol{X}\)</span> 以外によって説明される部分というふうに理解してください。</p>
<section id="boldsymbolbeta-の推定" class="level3">
<h3 class="anchored" data-anchor-id="boldsymbolbeta-の推定"><span class="math inline">\(\boldsymbol{\beta}\)</span> の推定</h3>
<p>回帰式を立てたとて、最も重要な回帰係数 <span class="math inline">\(\boldsymbol{\beta}\)</span> の値は私たちには知りようがありません。それは独立変数と従属変数の真の関係性であって、それを決めた神のような存在しか知り得ないためです。しかし人類は、これらの値を観察されたデータから推定する方法をいくつか発明しました。その中で最も有名な方法の一つが最小二乗法（OLS: Ordinary Least Squares）です。最小二乗法の具体的な計算方法はこのブログのレベルを超えるため述べません。一方、最小二乗法で計算した <span class="math inline">\(\boldsymbol{\beta}\)</span> の推定値が妥当である<a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>ためには、いくつかの仮定をクリアする必要があります。これらの仮定については、後ほど詳しく説明します。</p>
</section>
</section>
<section id="回帰表の解釈" class="level2">
<h2 class="anchored" data-anchor-id="回帰表の解釈">回帰表の解釈</h2>
<p>前節では、重回帰分析が、独立変数と従属変数の間の方程式の形の関係性における係数を推定する分析であることを説明しました。そこでこの節では、実際の学術論文で報告された回帰分析の結果の表を見ながら、どのように結果を解釈することができるのかを確認していきます。</p>
<section id="回帰表と回帰係数" class="level3">
<h3 class="anchored" data-anchor-id="回帰表と回帰係数">回帰表と回帰係数</h3>
</section>
<section id="推定の不確実性と信頼区間統計的仮説検定" class="level3">
<h3 class="anchored" data-anchor-id="推定の不確実性と信頼区間統計的仮説検定">推定の不確実性と信頼区間、統計的仮説検定</h3>
</section>
<section id="回帰分析の指標決定係数" class="level3">
<h3 class="anchored" data-anchor-id="回帰分析の指標決定係数">回帰分析の指標、決定係数</h3>
</section>
</section>
<section id="回帰係数が正しく推定されるための仮定" class="level2">
<h2 class="anchored" data-anchor-id="回帰係数が正しく推定されるための仮定">回帰係数が正しく推定されるための仮定</h2>
<p>これまで見てきたような回帰係数は、得られたデータから計算して推定されたものなのでした。では、この値は真の値を正しく推定できているのでしょうか。すでに述べた通り、推定した回帰係数が妥当であるためには、いくつかの仮定を満たしている必要があります。この節では、これらの仮定について具体的に説明します。そのためにまず先に4つの仮定を列挙し、その後それぞれについて説明します。計算式が列挙されていますが、それ自体を解釈する必要はありません (表現は西山ら(2019)に基づき、若干の変更を行った)。</p>
<ol type="1">
<li>i.i.d. の仮定
<ul>
<li><span class="math inline">\((Y_i, X_{1i}, X_{2i},\cdots, X_{Mi}), i = 1, \cdots, n\)</span> は、独立同一分布に従う。</li>
</ul></li>
<li>外生性の仮定
<ul>
<li><span class="math inline">\(E[\varepsilon_i\|X_{1i}, \cdots, X_{Mi}]=0\)</span></li>
</ul></li>
<li>多重共線性がない
<ul>
<li>任意の<span class="math inline">\(\Sigma_{j}a_j^2 = 1\)</span>となる <span class="math inline">\(a_0, \cdots, a_M\)</span>について、<span class="math inline">\(E[(a_0 + a_1X_{1i} + \cdots + a_MX_{Mi}^2)] &gt; 0\)</span>が成り立つ</li>
</ul></li>
<li>異常値がない</li>
</ol>
<ul>
<li><span class="math inline">\((X_{1i}, \cdots, X_{Mi}, \varepsilon_i)\)</span> は有限の4次のモーメントを持つ</li>
</ul>
<p>以下では数学的な議論というより、実際に分析を批判的に解釈する際に重要な考え方を述べます。先行研究の回帰分析が方法論的に正しく行われているのかを議論したり、自己の分析が妥当であることを主張したりする際の思考方法になります。</p>
<section id="i.i.d.-の仮定" class="level3">
<h3 class="anchored" data-anchor-id="i.i.d.-の仮定">1. i.i.d. の仮定</h3>
<div class="summary-box">
<p>
<strong>要約</strong>
</p>
<ul>
<li>
<b>i.i.d. (独立同一分布)</b> の仮定とは、各観測の変数の組が同一の分布に従って独立に実現しているという仮定
</li>
<ul>
<li>
この仮定が満たされていないと、回帰係数の標準偏差 (推定結果がどれくらい不確実か) が正しく推定されない
</li>
</ul>
<li>
<b>独立</b>とはある観測の変数の実現値が別の観測の値の実現に影響を与えないこと
</li>
<ul>
<li>
主に<b>系列相関</b>と<b>クラスタ相関</b>により破れうる
</li>
<li>
無作為抽出で対処可能。それが無理なら、自己回帰モデル・パネルデータ分析、固定効果モデルを用いる。
</li>
</ul>
<li>
<b>同一分布</b>とは、変数が同じ分布から実現すること
</li>
<ul>
<li>
<b>誤差項の分散不均一</b>が問題になることが多い
</li>
<li>
不均一分散に頑健な標準誤差の計算方法を用いる
</li>
</ul>
</ul>
</div>
<p>i.i.d. (independent and identical distribution) の仮定とは、日本語で独立同一分布の仮定といい、各観測の変数の組が<strong>同一の分布に従って独立に</strong>実現することを指します。以下では、i.i.d. の独立の部分と同一分布の部分についてそれぞれ簡単に説明を行います。</p>
<p>まず<strong>独立</strong>とは、ある観測の変数の実現値が別の観測の値の実現に影響を与えないことをいいます<a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>。ある人の教育レベルは別の人の教育レベルに影響を与えそうですし、ある人が新聞をとっているかどうかは同棲している別の人の政治への関心に影響を与えそうです。独立性の仮定が満たされない代表的な例は、系列相関やクラスタ相関がある場合です。</p>
<p>系列相関（または自己相関）とは、データに含まれる自己の過去の値が他の時期の値に影響を与えるようなことをいいます。例えば、あなたのある月の支出額は次の月のあなたの支出額と関係がありそうです。なぜなら、支出が多かった次の月は支出を減らそうと考えるかもしれないからであり、または、生活水準が上がり翌月もさらに豊かな暮らしをしようと支出を増やすかもしれないからです。</p>
<p>また、データのうち一部は同じ大学に通う人々かもしれず、同じコミュニティに属する人々は互いに影響を与えながら生活していることが予想されます。このような、特定の属性に固有の集団的な特徴が存在する場合、クラスタ相関が存在するといい、同様に独立性の仮定を破る原因になり得ます。</p>
<p>以上を踏まえれば、同じグループに属する対象や同じ対象そのものが複数回データに含まれる場合、i.i.d. が満たされない可能性があります。この問題に対処する最も原始的な方法は、<strong>母集団に対して無作為抽出を実施する</strong>ことです。しかし、社会科学において母集団に対する無作為抽出が行えることは稀であり (そもそも社会そのものが標本であるため)、構造的な理由により別の対処を考える必要があります。</p>
<p>自己相関の存在が疑われる場合、説明変数にラグを考慮した過去の値を表す変数を加えることにより対処するのが一般的です。これを一般化し、回帰モデルに時間の概念を加えたものが<strong>パネルデータ分析</strong>と呼ばれるものです。クラスター相関が疑われる場合、特定のグループに属しているかどうかのダミー変数をモデルに加えることにより対応する場合があります。この手法は固定効果 (Fixed Effect) モデルなどと言われたりします<a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>。</p>
<p>次に同一分布とは、各変数が同じ分布から実現することをいいます。出やすさの異なるサイコロを振るのはだめで、同じサイコロを何度も振り直しているようなイメージです。この部分に関する代表的な問題は、不均一分散です。分散とは簡単に言えばばらつきのことですが、ここでは特に誤差項の分散に関する議論を扱っています。誤差項とは、理論的な推定値（予測値）と真の値（観測値）との差をいうのでした。その分散が不均一であるとは、ある独立変数が変化すると、従属変数のばらつきが大きくなったり小さくなったりすることを意味します。例えば、60代の人々の年収と20代の人々の年収を比べると、両者の間でばらつきが同じであるとはいえないでしょう。このような状態を分散不均一とか不均一分散といいます。社会科学においてはむしろ、分散が均一である状態のほうが稀であると言えます。</p>
<p>不均一分散は、もともとの分布に関する仮定が破れていることになるため、無作為抽出などによって根本的に解決することはできません。そこで方法論的には、標準誤差の計算方法を補正することで対処します。具体的には、不均一分散に頑健な標準誤差を計算することによって、分析の妥当性を主張する場合が多いです。</p>
<p>以下は若干発展的です。i.i.d. の仮定が満たされていない場合、回帰係数の点推定には問題が起こりませんが、回帰係数の標準偏差（ばらつき; 分散とほとんど同じ）の推定量である標準誤差が正しく計算されない問題が生じます。つまり、回帰係数の不確実性の範疇がわからなくなり、0である（つまり効果がない）かどうかの検定もできなくなってしまいます。回帰表に表示される項目で言えば、標準誤差、信頼区間、p値の解釈ができなくなってしまいます。これは、せっかく回帰係数を推定したのに、それがどれくらい正しそうであるかの判断を無効にするという意味で深刻な問題です。そのため、上記で見たような方法論的な対処が求められるということになります。</p>
</section>
<section id="外生性の仮定" class="level3">
<h3 class="anchored" data-anchor-id="外生性の仮定">2. 外生性の仮定</h3>
<div class="summary-box">
<p>
<strong>要約</strong>
</p>
<ul>
<li>
<b>外生性の仮定</b>とは、独立変数と誤差項が相関していないという仮定
</li>
<ul>
<li>
交絡因子をモデルに入れ忘れた際に生じる (<b>選択バイアス</b>)
</li>
<li>
独立変数と従属変数に双方向の因果関係があるときに生じる (<b>同時性バイアス</b>)
</li>
</ul>
<li>
適切なモデルを構築することで対処が可能
</li>
<ul>
<li>
適切かどうかは理論的に説明するしかない
</li>
</ul>
<li>
理論的に適切なモデルを構築できない場合、別のモデルで対処する必要がある
</li>
<ul>
<li>
<b>操作変数法</b>などの方法がある (この章では扱わない)
</li>
<li>
上記のバイアスが生じていないかどうかを検定する方法もあるが、絶対ではない
</li>
</ul>
</ul>
</div>
<p>外生性 (exogeneity) の仮定とは、数学的には、独立変数を所与としたときに誤差項の期待値が <span class="math inline">\(0\)</span> であることをいいます。……と言われても正直ピンときません。</p>
<p>誤差項とは、理論値と実現値の差であると述べました。この差が存在することは、考慮している独立変数以外の変数によっても <span class="math inline">\(Y\)</span> の値が左右されていることを表しています。着目している独立変数 <span class="math inline">\(\boldsymbol{X}\)</span> がわかったときに誤差項が平均的に <span class="math inline">\(0\)</span> であるということは、<span class="math inline">\(\boldsymbol{X}\)</span> は (正確に <span class="math inline">\(Y\)</span> を予測できていないとしても) 平均的には正しく予測できていると言えます。すなわち、<span class="math inline">\(\boldsymbol{X}\)</span> を統制している条件下で、モデルは体系的な偏りを持っていないわけです。</p>
<p>では、<span class="math inline">\(\boldsymbol{X}\)</span> を統制している条件下で誤差項が体系的な偏りを持つとはどういうことでしょうか。繰り返しになりますが、誤差項は、<span class="math inline">\(Y\)</span> に影響を与えうる変数のうち、考慮している独立変数 <span class="math inline">\(\boldsymbol{X}\)</span> 以外の全てを含んでいます。これが独立変数により偏るということは、<strong>誤差項に含まれる何らかの変数と独立変数との間で相関関係がある</strong>ことを意味します。したがって、外生性の仮定が破れることは、そのような変数を適切にモデルに組み込めていないことと言い換えることができます。</p>
<p>以下では、外生性の仮定が満たされない状況を大きく2つ説明します。すなわち、(1) 選択バイアスが生じている場合と、(2) 同時性バイアスが生じている場合です。なお、外生性の仮定が満たされていない状況を、内生性の問題ということがあります。</p>
<p>第一に選択バイアス (セレクションバイアス) とは、独立変数にも従属変数にも影響を与える変数をモデルに組み込めていないときに生じる体系的な偏りのことをいいます。必要な外生変数が欠落しているという意味で欠落変数バイアス (脱落変数バイアス、OVB; Omitted Variable Bias) とも言います。また、このような変数を交絡因子と呼びます。</p>
<p>選択バイアスに対処する方法は、より適切なモデルを構築することにほかなりません。つまり、<strong>独立変数以外に存在するあらゆる変数が、独立変数と相関を持たない</strong>と主張できる回帰モデルを構築する必要があります。逆に言えば、交絡因子を一つ示すだけで推定結果に疑義を呈することができます。独立変数以外に存在するあらゆる変数が独立変数と相関を持たないこと、つまり交絡因子が存在しないことは、理論的に主張するほかありません (悪魔の証明というやつ)。そして、交絡因子と思われる変数は全てモデルに組み込んで回帰分析を行う必要があるということです。</p>
<p>内生性の問題を生じさせる第二の原因は、同時性バイアス<a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>です。これは、独立変数と従属変数の間で相互に因果関係が存在する場合に生じる問題です。有名な例は、需要と供給、犯罪率と警察署の数、2プレイヤーの意思決定などでしょうか<a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>。このように、従属変数から独立変数に向かう因果関係が存在する場合にも、外生性の仮定が満たされません。なお余談ですが、ある時期の従属変数が未来の独立変数に影響を与え、それを通して未来の従属変数にも影響を与えているという意味では、交絡因子と捉えて選択バイアスの一種であると考えることができるかもしれません。</p>
<p><a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>: 政治学では「同時性バイアス」という名前はあまり一般的ではないかもしれません。双方向の因果関係が存在する等と言い換えることができます。この言葉は、ミクロ経済学における同時方程式の考え方 (モデル) に由来します。</p>
<p><a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>: 最後の例は若干理論的かもしれません。プレイヤーは相手の行動や応答すなわち従属変数の値を予測して、自己の行動 (独立変数) を決定する場合があります。このとき、従属変数から独立変数に対する因果関係が存在するといえます。</p>
<p>同時性バイアスについても、理論的な主張によってモデルの正しさを示すことしかできません。その意味で外生性の仮定は、分析を通して妥当性を主張する必要のある多少厄介な問題であるといえます。</p>
<p>なお、誤解されることが多いのですが、<span class="math inline">\(Y\)</span> に影響を与える変数をモデルに含めないことそれ自体は、分析に大きな影響を与えません。そのような変数が誤差項として捉えられていて、かつ、独立変数と相関を持っていないような場合、外生性の仮定は満たされています。したがって、着目する独立変数の回帰係数の推定には問題を生じさせません。もちろん、<span class="math inline">\(Y\)</span> を予測する精度は落ちると言えますが、私たちの目的は <span class="math inline">\(Y\)</span> の予測ではありません。平均的には誤差が <span class="math inline">\(0\)</span> であるのであれば、やはり分析上の問題とは言えないわけです。</p>
<p>最後に、(少なくとも政治学の分析において) 外生性の仮定を満たすためにモデルに加えた変数のことを特に統制変数といいます。式の見かけ上は独立変数と変わりありませんが、係数の値には (それが正しいのかさえ) 興味がなく、方法論上必要なためモデルに加えた変数のことです。そのような理由により加えているわけですから、<strong>統制変数の回帰係数が正しく推定されるために努力する必要はありませ</strong>んし、その意味で<strong>統制変数の回帰係数は解釈してはいけません</strong>。その値が信頼に値するかわかりませんし、そもそも信頼に値する必要がないのです。すべては着目する独立変数の回帰係数の推定が正しいかどうかです。</p>
</section>
<section id="多重共線性がない" class="level3">
<h3 class="anchored" data-anchor-id="多重共線性がない">3. 多重共線性がない</h3>
<div class="summary-box">
<p>
<strong>要約</strong>
</p>
<ul>
<li>
<b>多重共線性</b>とは、2つ以上の独立変数の間に強い相関関係があることをいう
</li>
<ul>
<li>
<b>完全な多重共線性</b>：一方の値が決まるともう一方の値も決まる
</li>
<li>
<b>弱い多重共線性</b>：強い相関関係があり、高い精度でもう一方を予測できる
</li>
</ul>
<li>
完全な多重共線性が生じているとき、回帰係数は推定できない
</li>
<li>
弱い多重共線性が生じているとき、回帰係数の推定が不安定になる
</li>
<ul>
<li>
サンプルサイズを大きくすることで対処する場合がある
</li>
</ul>
</ul>
</div>
<p>回帰係数が正しく推定される第3の仮定は、多重共線性がないことです。多重共線性とは、厳密には<strong>独立変数の間に線形な (一次関数的な) 関係があること</strong>と説明されます。噛み砕いて言えば、2つ以上の独立変数について、片方の値がわかるともう一方の値もわかる方程式的な関係にあるということです。このような厳密な意味での多重共線性を、「完全な多重共線性」ということがあります。例えば、ある商品のUSドル価格と日本円価格は、レートを掛け算するだけで交換可能なため、完全な多重共線性の関係にあります。</p>
<p>完全な多重共線性が生じているとき、モデルには2つ以上の<strong>同じ情報を持った独立変数が含まれる</strong>ことになります。この状態で回帰係数を推定しようとしても、各変数からの影響を区別することはできず、推定することができなくなります。これをパラメタの識別ができないと表現します。</p>
<p>完全な多重共線性が問題になることはめったにありません。なぜなら、モデルを注意深く見ていればそもそも起こりにくい問題ですし、万が一同じ変数をモデルに入れてしまっていた場合は、統計ソフトがそれを教えてくれるからです (推定できないよ！ とエラーが出る)。強いて言えば、完全な多重共線性の関係にあるが、一部のデータ入力のミスで完全でなくなってしまったような場合、エラーが出なくてわからないが推定が不安定という問題が生じることがあるかもしれません。この問題も、注意深くモデルを構築すれば起こりにくいことです。</p>
<p>多重共線性をより広い意味で捉えることがあります。すなわち、2つ以上の独立変数について、片方の値がわかるともう一方の値が高い精度で予測できるほどに強い相関関係がある場合です。これを弱い多重共線性といいます<a href="強い相関関係があるのに弱い多重共線性というのは少し紛らわしく感じます。実際には、完全な多重共線性の仮定よりも弱い仮定という意味です。"></a>。例えば、期末テストの点数と中間テストの点数とかでしょうか。</p>
<p>弱い多重共線性が生じているとき、それらの変数の回帰係数の推定が不安定になることがあります。完全な多重共線性の問題と同様に、識別が困難なほどに強い関係性がある場合に生じる問題です。これに対処するには、弱い多重共線性が起きている変数のうち不要な方をモデルから除外するという方法が考えられます。その変数が特に理由もなくモデルに含まれているのであれば、この方法は有効です。しかし、両方が興味のある変数であれば、モデルから除外することはできません。また、外生性の仮定のために含んでいる場合も、除外すれば選択バイアスが生じます。また、統制変数同士に多重共線性が起きている場合であっても、その回帰係数が正しいかには興味がないため、やはりモデルから除外する必要はありません。</p>
<p>それを考えると、弱い多重共線性が存在しているからといって変数をモデルから除外する必要は必ずしもありません。回帰係数の推定の精度を上げるという意味では、サンプルサイズを大きくすることが有効な対処になります。</p>
<p>なお以上の説明から明らかなように、多重共線性の問題は2つ以上の独立変数がモデルに含まれる重回帰分析に固有の仮定です。これに対し、独立変数が1つしかないモデルを単回帰モデルといい、単回帰モデルでは多重共線性の問題はふつう問題になりません。</p>
</section>
<section id="異常値がない" class="level3">
<h3 class="anchored" data-anchor-id="異常値がない">4. 異常値がない</h3>
<p>最後の仮定は、モーメントという難しい単語が出ています。これは漸近正規性という統計的な性質を満たすために必要な仮定であって、理論的に解釈どうこうという仮定ではありません。ただしタイトルにもあるとおり、この仮定が満たされているとき、データは異常値 (明らかに大きいまたは小さい値であって、正しくないと思われるもの) がないことが保証されます。実際、データ分析を行う際には欠損値や異常値に適切に対処しないと結果に悪影響を与えることから、分析の際のデータの正しさを担保する仮定であると言えます。</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "コピーしました");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "コピーしました");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/stats1230\.github\.io\/lab-desk");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>